/*
 * Copyright 2015 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.template.soy.jssrc.internal;

import static com.google.template.soy.jssrc.dsl.Expression.dottedIdNoRequire;
import static com.google.template.soy.jssrc.dsl.Statement.assign;

import com.google.common.collect.ImmutableList;
import com.google.template.soy.base.internal.SanitizedContentKind;
import com.google.template.soy.error.ErrorReporter;
import com.google.template.soy.jssrc.dsl.Expression;
import com.google.template.soy.jssrc.dsl.GoogRequire;
import com.google.template.soy.jssrc.dsl.JsDoc;
import com.google.template.soy.jssrc.dsl.Statement;
import com.google.template.soy.jssrc.dsl.VariableDeclaration;
import com.google.template.soy.soytree.AbstractSoyNodeVisitor;
import com.google.template.soy.soytree.SoyFileNode;
import com.google.template.soy.soytree.SoyFileSetNode;
import com.google.template.soy.soytree.SoyNode;
import com.google.template.soy.soytree.SoyNode.ParentSoyNode;
import com.google.template.soy.soytree.TemplateDelegateNode;
import com.google.template.soy.soytree.TemplateNode;
import com.google.template.soy.soytree.Visibility;
import com.google.template.soy.soytree.defn.TemplateParam;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/** Generates Lit-HTML code based off of a Soy template. This is basically a shim. */
public final class GenLitCodeVisitor extends AbstractSoyNodeVisitor<List<String>> {

  private TemplateAliases templateAliases = null;
  private JsCodeBuilder jsCodeBuilder;
  private List<String> jsFilesContents;

  @Override
  protected void visit(SoyNode node) {
    try {
      super.visit(node);
    } catch (RuntimeException e) {
      throw new AssertionError(
          "error from : " + node.getKind() + " @ " + node.getSourceLocation(), e);
    }
  }

  public List<String> gen(SoyFileSetNode node, ErrorReporter errorReporter) {
    try {
      jsFilesContents = new ArrayList<>();
      jsCodeBuilder = null;
      visit(node);
      return jsFilesContents;
    } finally {
    }
  }

  @Override
  protected void visitSoyFileSetNode(SoyFileSetNode node) {
    for (SoyFileNode soyFile : node.getChildren()) {
      visit(soyFile);
    }
  }

  /**
   * Helper for visitSoyFileNode(SoyFileNode) to generate a module definition.
   *
   * @param soyFile The node we're visiting.
   */
  private void addCodeToDeclareGoogModule(StringBuilder header, SoyFileNode soyFile) {
    String exportNamespace = soyFile.getNamespace() + ".lit";
    header.append("goog.module('").append(exportNamespace).append("');\n\n");
  }

  @Override
  protected void visitSoyFileNode(SoyFileNode node) {
    StringBuilder file = new StringBuilder();

    file.append("// This file was automatically generated by the Soy compiler.\n")
        .append("// Please don't edit this file by hand.\n")
        // This "source" comment makes Code Search link the gencode to the Soy source:
        .append("// source: ")
        .append(node.getFilePath().path())
        .append('\n');

    // Output a section containing optionally-parsed compiler directives in comments. Since these
    // are comments, they are not controlled by an option, and will be removed by minifiers that do
    // not understand them.
    file.append("\n");
    String fileOverviewDescription = "Templates in namespace " + node.getNamespace() + ".";
    JsDoc.Builder jsDocBuilder = JsDoc.builder();
    jsDocBuilder.addAnnotation("fileoverview", fileOverviewDescription);
    file.append(jsDocBuilder.build());
    file.append("\n\n");
    jsCodeBuilder = new JsCodeBuilder();

    templateAliases = AliasUtils.createTemplateAliases(node);

    addCodeToDeclareGoogModule(file, node);

    // Add code for each template.
    for (TemplateNode template : node.getTemplates()) {
      jsCodeBuilder.appendLine().appendLine();
      visit(template);
    }
    jsCodeBuilder.appendGoogRequiresTo(file);
    jsCodeBuilder.appendCodeTo(file);
    jsFilesContents.add(file.toString());
    jsCodeBuilder = null;
  }

  @Override
  protected void visitTemplateNode(TemplateNode node) {
    SanitizedContentKind kind = node.getContentKind();
    // Attribute templates do not have an equivalent type in lit-html
    if (kind == SanitizedContentKind.ATTRIBUTES
        || node instanceof TemplateDelegateNode
        || node.getVisibility() == Visibility.PRIVATE) {
      return;
    }
    ImmutableList.Builder<Statement> declarations = ImmutableList.builder();
    String templateName = node.getTemplateName();
    String alias = templateAliases.get(templateName);
    String partialName = node.getLocalTemplateSymbol();
    Expression aliasExp = dottedIdNoRequire(alias);
    JsDoc jsDoc = generateFunctionJsDoc(alias);

    Expression function = Expression.function(jsDoc, generateFunctionBody());

    declarations.add(VariableDeclaration.builder(alias).setJsDoc(jsDoc).setRhs(function).build());
    declarations.add(assign(JsRuntime.EXPORTS.dotAccess(partialName), aliasExp));
    if (!hasOnlyImplicitParams(node)) {
      declarations.add(
          aliasExp
              .dotAccess("Params")
              .asStatement(
                  JsDoc.builder()
                      .addParameterizedAnnotation("typedef", genParamsRecordType(node))
                      .build()));
    }
    jsCodeBuilder.append(Statement.of(declarations.build()));
  }

  /** Generate the JSDoc for the opt_data parameter. */
  private String genParamsRecordType(TemplateNode node) {

    // Generate members for explicit params.
    Map<String, String> record = new LinkedHashMap<>();
    for (TemplateParam param : node.getParams()) {
      if (param.isImplicit()) {
        continue;
      }
      JsType jsType = JsType.forLitSrc(param.type());
      String typeForRecord = jsType.typeExprForRecordMember(/* isOptional= */ !param.isRequired());
      record.put(param.name(), typeForRecord);
      for (GoogRequire require : jsType.getGoogRequires()) {
        jsCodeBuilder.addGoogRequire(require);
      }
    }
    return JsType.toRecord(record);
  }

  private boolean hasOnlyImplicitParams(TemplateNode node) {
    for (TemplateParam param : node.getParams()) {
      if (!param.isImplicit()) {
        return false;
      }
    }
    return true;
  }

  private JsDoc generateFunctionJsDoc(String alias) {
    JsDoc.Builder jsDocBuilder = JsDoc.builder();
    jsDocBuilder.addParam(StandardNames.DOLLAR_DATA, "!" + alias + ".Params");
    jsDocBuilder.addParameterizedAnnotation("return", "lit_element.TemplateResult");
    return jsDocBuilder.build();
  }

  private Statement generateFunctionBody() {
    return Statement.throwValue(
        Expression.construct(
            Expression.id("Error"),
            Expression.stringLiteral("No implementation yet for the lit soy backend")));
  }

  @Override
  protected void visitChildren(ParentSoyNode<?> node) {
    for (SoyNode child : node.getChildren()) {
      visit(child);
    }
  }
}
