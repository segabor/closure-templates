# Rendering a Template in Java

[TOC]

## How do I render a Soy template using Java?

### Prerequisite: Compiling the template in Java

The first step is to use the Soy compiler to compile a `.soy` file to a
corresponding Java `jar` file. There are multiple ways to do that.


See [Compiling Templates](dir.md) for more details.

### Creating a `SoySauce` object {#create-soysauce}

Then your application can depend on the generated `jar` files and you can render
templates by generating a `SoySauce` object via the `SoySauceBuilder` API. For
example,

```java
import com.google.template.soy.jbcsrc.api.SoySauce;
import com.google.template.soy.jbcsrc.api.SoySauceBuilder;
...
SoySauce soySauce = new SoySauceBuilder().build();
```

When using SoySauceBuilder you may need to pass additional parameters:

*   if you are using legacy SoyPrintDirect of SoyFunction plugins, you will need
    to pass them to the `withDirectives` and `withFunctions` methods
*   if you are using SoyJavaSourceFunctions that require plugin instances at
    runtime, you will need to pass `Suppliers` for those instances to the
    `withPluginInstances`
*   if your compiled templates are not available on the standard runtime
    classpath of your JavaProgram, you may need to call `withClassLoader` to
    provide an alternate classloader.

### Getting the Renderer for a given template

You can then obtain the [`Renderer`][renderer-source-link] object for a given
template. Simply call `SoySauce.renderTemplate()` with the full template name.
For example, for the following Soy file,

```soy
// Content of examples.soy
{namespace soy.examples}

{template .foo}
  ...
{/template}
```

Use the following code to get the `Renderer` object.

```java
SoySauce soySauce = ...;

SoySauce.Renderer renderer = soySauce.renderTemplate("soy.examples.foo");
```

### Configuring the Renderer

The `Renderer` has setter methods to let you further configure your render:


Here is an example template:

```soy
{namespace soy.examples}

/** Says hello to a list of persons. */
{template .helloName}
  {@param names: list<string>}
  {for $name in $names}
    Hello {$name}!
  {/for}
{/template}
```

In Java, you can pass the template data to the renderer:

```java
SoySauce.Renderer renderer = soySauce.renderTemplate("soy.examples.helloName");
renderer = renderer.setData(ImmutableMap.of("names", ImmutableList.of("Alice", "Bob")));
```

The table below lists the template data types and their corresponding Java
types:

Template Type             | Java Type
------------------------- | ---------------------
`null`                    | `null`
`bool`                    | `boolean`
`int`                     | `int`
`float`                   | `double`
`string`                  | `java.lang.String`
`list<T>`                 | `java.util.List<T>`
`map<K, V>`               | `java.util.Map<K, V>`
`legacy_object_map<K, V>` | `java.util.Map<K, V>`

[Maps](../reference/types#map) and
[legacy object maps](../reference/types#legacy_object_map) can both be rendered
using `java.util.Map`s. Soy can usually infer which kind of map is intended.
This means that if you change a template parameter from `legacy_object_map` to
`map`, you do not need to change its backing value in Java. (This is different
from the situation in JavaScript, where you *do* need to
[change the backing value](js#template-data).)

Maps can contain non-string keys (ints, proto enums, etc.), while legacy object
maps cannot.


### Synchronous Rendering

The easiest way to render a template is to directly call
`renderer.render().get()`. This gives you a string for the rendered template.

For instance, if you call `renderer.render().get()` for the last example,

```java
String result = renderer.render().get();
```

`result` will be `"Hello Alice!Hello Bob!"`.

You can also use `renderStrict()` method to get a `SanitizedContent` object,
which can then be converted to safe HTML, trusted resource url, or other
sanitized types based on your content kind.

All of these APIs return `Continuation` objects which allow asynchronous
rendering. However, directly calling `get()` on them will throw an exception if
there are any incomplete futures. For asynchronous rendering, please check the
[Advanced Java Rendering](adv-java.md) page.

[renderer-source-link]: https://github.com/google/closure-templates/blob/master/java/src/com/google/template/soy/jbcsrc/api/SoySauce.java#L43

## Migrating to the Type-Safe API {#type-safe}

In late 2019 we introduced a new type-safe generated Java API. Instead of
passing around a loosely typed `String` for a template name and `Map<String, ?>`
for template parameters, this new generated API creates a strongly typed,
immutable data class and builder for every Soy template.

NOTE: All users are encouraged to upgrade to the new API. Classes generated by
the old API will be marked as `@Deprecated` as the new API matures.

### Steps to upgrade

Let's assume you have the following build and source artifacts:

*   A Soy file name `main.soy`.
*   A template in `main.soy` named `.index` with three template parameters,
    `title`, `message`, and `count`.

```soy
{template .index}
  {@param title: string}
  {@param message: html}
  {@param count: int}
  ...
{/template}
```

*   An `af_soy_library` named `mysoy` containing `main.soy`
*   A `java_library` named `server` that contains Java code that renders
    `.index`.

Perform these steps:

1.  Each `af_soy_library` build rule now generates a corresponding
    `java_library` containing the new generated API. In this example it is
    called `mysoy_java_builders`. Add this target to the dependencies of
    `server`. You can remove the old generated API, `mysoy_java_infos`, from the
    dependencies if it's there.

1.  In your Java code that renders `.index` instead of creating a `Map<String,
    ?>` for the template data, use the corresponding builder class.

    ```java
    MainTemplates.Index params = MainTemplates.Index.builder()
        .setTitle(...)
        .setMessage(...)
        .setCount(...)
        .build();
    ```

    Note that the arguments to the builder setter methods are strongly typed and
    match the types declared in the Soy template. Some amount of type coercion
    may be necessary to get this to compile.

    If the template has zero parameters you can use
    `MainTemplates.Index.getDefaultInstance()` as a shortcut.

1.  Update the invocation of the rendering API. Locate the overloaded method in
    the rendering API that takes a `SoyTemplate` and call it
    (`MainTemplates.Index` implements `SoyTemplate`). For example, you would
    call the SoySauce rendering API as follows:

    ```java
    soySauce.newRenderer(params).renderHtml();
    ```

    Note that you don't explicitly pass "template name" in the new API as this
    information is now contained in the `Index` class.

